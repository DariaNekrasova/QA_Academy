Интеграционное тестирование через API Part 2:
------------------------------------------------------------- Аутентификация, аутентификация -----------------------------------------------------------------------
1. Аутентификация
Большинство приложений стремится обрести новых пользователей,
поэтому необходимо разработать механизм, позволяющий пользователям
регистрироваться, аутентифицироваться и менять свои учётные данные.

Можно выделить два основных типа аутентификации:

Запоминающая предыдущее состояние — реализуется с помощью сессий.
Пользователь авторизуется один раз, а затем получает возможность
свободно передвигаться по приложению и доступ к защищенным ресурсам
(таким, как банковские транзакции или селфи в Snapchat), не отправляя
данные, которые подтверждают его вход повторно.
Не запоминающая предыдущее состояние — реализуется с помощью токенов.
Пользователи делают все то же самое, но при выполнении каждого HTTP-запроса
пользователю нужно отправлять идентификационные данные. Так обычно
поступают с REST API. Сейчас золотой стандарт, не запоминающей
состояние аутентификации с токенами, — JWT.
Есть и более продвинутый сценарий — многофакторная аутентификация.
Она повышает безопасность приложения, добавляя дополнительные уровни
защиты к логину и паролю. Хорошие примеры реализации есть у Google и Amazon.

Прим. перев.  А у нас есть разъясняющая статья про двухфакторную аутентификацию и протокол FIDO U2F.

OAuth — другой широко распространенный сценарий. Он дает пользователям вашего
приложения возможность зарегистрироваться и войти в него одним кликом, используя
аккаунт одной из социальных сетей. Аутентификация происходит за счет того, что
пользователи предоставляют вашему приложению некоторые свои данные из социальной
сети, но при этом не вводят их вручную.

2. Роли, разрешения и контроль доступа
Многие путают авторизацию с аутентификацией, не понимая, что это разные понятия.
Аутентификация определяет то, как пользователь входит в приложение. Авторизация же
определяет то, что пользователь имеет право делать после входа.

Запутались? Объясню подробнее. Смысл слоя, отвечающего за авторизацию, — это выдача
разрешений, поддержание безопасности личной информации, отказ в доступе к конкретным
действиям и, где требуется, аннулирование привилегий, чтобы одни пользователи не
пробирались в аккаунты других и не смотрели их личные фотографии. Логика разрешений проста:

Пользователь x может сделать действие y с объектом z.

Применим это в конкретной ситуации: Шэрон — редактор и может редактировать посты. Тогда надо определить:

роль Шэрон — редактор;
ее действие — редактирование;
объекты, с которыми она может это делать, — посты.
Как это работает? Просто: булевы переменные. Вы возвращаете True/False в зависимости от
того, что и кому разрешено делать с конкретным объектом. Итак, может ли Шэрон
редактировать какой-то конкретный пост? Вернуть True, если она редактор, вернуть
False и закрыть доступ к посту, если нет.


------------------------------------------------------------- Сравнение JSON, парсинг средствами JAVA -------------------------------------------------------------
------------------------------------------------------------- Моки и стабы ----------------------------------------------------------------------------------------
------------------------------------------------------------- Создаем моки на Mockito -----------------------------------------------------------------------------
------------------------------------------------------------- Создаем моки на WireMock ----------------------------------------------------------------------------

Практика:
Извлечение JSONs и соотв.запросов из бизнес-процесса (например, оформление портфолио через браузер), PUT, POST заросы
Написание автотестов по простым кейсам (отправить запрос, проверить статус/боди и тд)
Начать писать контроллеры, начало разработки реального фреймоврка для тестирвоания приложения (TM/RM etc).