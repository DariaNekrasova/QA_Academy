UI-автоматизация Part 2:
------------------------------------------------------------- Разбиение логики и реализации -------------------------------------------------------------
~не всегда получается реализовать то, что выглядит логично
(выход из поля табом вместо клика и тд)

подходы:
https://selenium2.ru/docs/test-design-considerations.html
------------------------------------------------------------- другие паттерны ---------------------------------------------------------------------------
https://selenium2.ru/docs/test-design-considerations.html

Тестирование управляемое данными
Тестированием управляемым данными (DDT, Data Driven Testing) называют такой процесс,
когда одинаковый тест выполняется множество раз используя меняющиеся тестовые данные.
Подобные наборы данных, как правило, хранятся во внешних файлах (например .csv или текстовый файл)
или загружаются из баз данных. Техника тестирования DDT широко используется, когда необходимо проверить,
как приложение обрабатывает различные вводимые значения. В таком случае можно легко создавать новые тесты,
без изменения кода тестового скрипта, просто добавляя новые варианты данных в файл.

В Python:

# Строковый массив значений из файла
source = open("input_file.txt", "r")
values = source.readlines()
source.close()
# Цикл для вызова функции Поиска, для каждого значения из массива
for search in values:
    sel.open("/")
    sel.type("q", search)
    sel.click("btnG")
    sel.waitForPageToLoad("30000")
    self.failUnless(sel.is_text_present("Results * for " + search))
В вышеприведенном примере сначала открывается файл. В этом файле содержатся различные
строковые переменные, содержащие поисковый запрос. Потом все переменные сохраняются в
отдельном массиве. Затем в цикле для каждого значения из массива выполняется поиск и
полученный результат проверяется.

Это очень простой пример, но нам лишь хотелось показать, что, используя язык программирования,
очень легко написать тест, который будет выполняться для изменяющихся данных. Для получения
более подробной информации просмотрите нашу вики Selenium RC. К тому же тестирование управляемое
данными довольно частая тема и среди тех профессионалов автоматического тестирования, которые не
используют Selenium. Поэтому вы можете найти множество блогов и форумов по запросу “data-driven testing” ..
вики Selenium RC: http://wiki.openqa.org/pages/viewpage.action?pageID=21430298


Карта пользовательского интерфейса
Карта пользовательского интерфейса - практика написания кода, при которой все локаторы
вашего тестового набора располагаются в одном месте, что упрощает их последующую модификацию
в случае, если идентификаторы или пути к элементам тестируемого приложения были изменены.
Скрипт использует карту интерфейса для нахождения тестируемых элементов. Проще говоря, карта
интерфейса это репозиторий, в котором содержатся объекты тестового кода, связанные с элементами
интерфейса тестируемого приложения.

Что же полезного в карте интерфейса? Ее главная задача - облегчить обслуживание скрипта.
Например когда необходимо отредактировать локатор, то гораздо проще найти объект в едином
центральном хранилище, чем искать его по всему коду. К тому же, это позволяет редактировать
идентификатор в одном месте, а не изменять несколько значений по всему скрипту, или, того хуже,
в коде сразу нескольких скриптов.

Подытоживая, можно сказать, что использование карты интерфейса предоставляет два
значительных преимущества:

вместо того, чтобы разбрасывать по всему коду объекты пользовательского интерфейса, используется
централизованное хранилище. Это упрощает последующую поддержку скриптов;
позволяет придать генерируемым (зашифрованным) HTML-идентификаторам более удобочитаемые имена,
что позволяет улучшить восприятие кода.
Ознакомьтесь со следующим тяжело поддающимся восприятию отрывком Java кода:

public void testNew() throws Exception {
             selenium.open("http://www.test.com");
             selenium.type("loginForm:tbUsername", "xxxxxxxx");
             selenium.click("loginForm:btnLogin");
             selenium.click("adminHomeForm:_activitynew");
             selenium.waitForPageToLoad("30000");
             selenium.click("addEditEventForm:_IDcancel");
             selenium.waitForPageToLoad("30000");
             selenium.click("adminHomeForm:_activityold");
             selenium.waitForPageToLoad("30000");
}
Такой код тяжело прочитать людям, не знакомым с исходниками тестируемого приложения.
Даже постоянным пользователям приложения трудно будет сказать, что делает данный скрипт.
Гораздо лучше написать следующим образом:

public void testNew() throws Exception {
             selenium.open("http://www.test.com");
             selenium.type(admin.username, "xxxxxxxx");
             selenium.click(admin.loginbutton);
             selenium.click(admin.events.createnewevent);
             selenium.waitForPageToLoad("30000");
             selenium.click(admin.events.cancel);
             selenium.waitForPageToLoad("30000");
             selenium.click(admin.events.viewoldevents);
             selenium.waitForPageToLoad("30000");
}
Теперь при помощи нескольких комментариев, отступов и карты интерфейса можно получить легко читаемый скрипт.

public void testNew() throws Exception {

             // Открываем ссылку
             selenium.open("http://www.test.com");

             // Вводим имя пользователя
             selenium.type(admin.username, "xxxxxxxx");

             // Нажимаем на кнопку "Войти в систему"
             selenium.click(admin.loginbutton);

             // Нажимаем на кнопку "Создать событие"
             selenium.click(admin.events.createnewevent);
             selenium.waitForPageToLoad("30000");

             // Нажимаем на кнопку "Отмена"
             selenium.click(admin.events.cancel);
             selenium.waitForPageToLoad("30000");

             // Нажимаем на кнопку "Посмотреть события"
             selenium.click(admin.events.viewoldevents);
             selenium.waitForPageToLoad("30000");
}
Реализовать карту пользовательского интерфейса можно разными способами: сделать отдельный
класс или присвоить локаторам отдельные глобальные строковые переменные. В качестве альтернативы
можно использовать текстовый файл, содержащий пары ключ-значение. Для языка Java такой файл -
наиболее предпочтительный метод.

Рассмотрим файл свойств prop.properties присваивающий локаторам удобочитаемые псевдонимы
из предыдущего примера.

admin.username = loginForm:tbUsername
admin.loginbutton = loginForm:btnLogin
admin.events.createnewevent = adminHomeForm:_activitynew
admin.events.cancel = addEditEventForm:_IDcancel
admin.events.viewoldevents = adminHomeForm:_activityold
Все локаторы по прежнему ссылаются на объекты html. Но мы создали уровень абстракции между кодом
тестов и элементами пользовательского интерфейса. Все значения считываются из файла и используются
в тестовых классах в качестве карта пользовательского интерфейса.

++ PageFactory


------------------------------------------------------------- PageObject, пара его примеров -------------------------------------------------------------
Page Objects
Паттерн Page Objects хорошо зарекомендовал себя в автоматизации тестирования.
Основная идея – инкапсулировать логику поведения страницы в классе страницы.
Таким образом, тесты будут работать не с низкоуровневым кодом технического
драйвера, а с высокоуровневой абстракцией.

Основные преимущества Page Objects:
Разделение полномочий: вся «бизнес-логика» страницы должна помещаться
в Page Objects, классы тестов лишь вызывают публичные методы и
проверяют результат
DRY – все локаторы помещаются в одном месте. Если когда UI изменится,
то мы изменим локатор лишь в одном месте
Скрытие слоя технического драйвера. Ваши тесты будут работать с высокоуровневой
абстракцией. В будущем, возможно, вы захотите сменить драйвер: например,
использовать PhantomJS, или вообще для каких-то участков отказаться от
использования WebDriver, для улучшения производительности. В этом случае,
вам придется заменить только код Page Objects. Тесты останутся неизменными
Page Objects позволяет записать локаторы в декларативном стиле

в т.ч. тут
https://habr.com/ru/post/178407/
Page Object:
https://comaqa.gitbook.io/selenium-webdriver-lectures/page-object-pattern.-arkhitektura-testovogo-proekta./ispolzovanie-patterna-page-object.
http://internetka.in.ua/selenium-page-object/
от создателей селениума:
https://selenium2.ru/docs/test-design-considerations.html

------------------------------------------------------------- Кондишены, ожидания -----------------------------------------------------------------------

Ожидания - непременный атрибут любых UI тестов для динамических приложений.
Нужны они для синхронизации работы AUT и тестового скрипта.
Скрипт выполняется намного быстрее реакции приложения на команды,
поэтому часто в скриптах необходимо дожидаться определенного состояния
приложения для дальнейшего с ним взаимодействия.
Самый простой пример - переход по ссылке и нажатие кнопки:

driver.get("http://google.com");
driver.findElement(By.id("element_id")).click();

В данном случае необходимо дождаться пока не появится кнопка с
id = element_id и только потом совершать действия над ней.
Для этого и существуют ожидания.

Ожидания бывают: 1. Неявные ожидания - Implicit Waits - конфигурируют
экземпляр WebDriver делать многократные попытки найти элемент (элементы)
на странице в течение заданного периода времени, если элемент не найден сразу.
Tолько по истечении этого времени WebDriver бросит ElementNotFoundException.

    WebDriver driver = new FirefoxDriver();
    driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
    driver.get("http://some_url");
    WebElement dynamicElement = driver.findElement(By.id("dynamicElement_id"));

Неявные ожидания обычно настраиваются сразу после создания экземпляра WebDriver
и действуют в течении всей жизни этого экземпляра, хотя переопределить их можно
в любой момент. К этой группе ожиданий также можно отнести неявное ожидание загрузки
страницы: driver.manage().timeouts().pageLoadTimeout(10, TimeUnit.SECONDS); А также
неявное ожидание отработки скриптов: driver.manage().timeouts().setScriptTimeout(10, TimeUnit.SECONDS); 2.
Явные ожидания - Explicit Waits - это код, который ждет наступления какого-то события (чаще всего на AUT),
прежде чем продолжит выполнение команд скрипта. Такое ожидание срабатывает один раз в указанном месте.</p>

Самым худшим вариантом является использование ``` Thread.sleep(1000)```, в случае с которым
скрипт просто будет ждать определенное количество времени. Это не гарантирует наступление
нужного события, либо будет слишком избыточным и увеличит время выполнения теста.

Более предпочтительно использовать WebDriverWait и ExpectedCondition:
WebDriver driver = new FirefoxDriver();
driver.get("http://some_url");
WebElement dynamicElement = (new WebDriverWait(driver, 10))
  .until(ExpectedConditions.presenceOfElementLocated(By.id("dynamicElement_id")));

В данном случае скрипт будет ждать элемента c id = dynamicElement_id в течении 10 секунд,
но продолжит выполнение, как только элемент будет найден. При этом WebDriverWait класс
выступает в роли конфигурации ожидания - задаем, как долго ждать события и как часто
проверять его наступление. ExpectedConditions - статический класс, содержащий часто
используемые условия для ожидания.

++ явные/неявные ожидания + реализация с selenium
https://selenium2.ru/docs/webdriver-advanced-usage.html


------------------------------------------------------------- Humcrest, матчеры -------------------------------------------------------------------------
Humcrest, матчеры:
https://sysout.ru/rabota-s-hamcrest/
http://hamcrest.org/JavaHamcrest/
AssertJ:
https://www.baeldung.com/introduction-to-assertj

++ матчеры
https://habr.com/ru/company/yandex/blog/184634/
~ матчеры — маленькие объекты, которые содержат логику принятия решения, знают, что ждали и что получили, о чем самостоятельно сообщают.

Практика:
Написание простейшего фреймворка для UI-автоматизации и несколько тестов. Расширение возможности WebElement по необходимости.